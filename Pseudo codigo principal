typedef struct {
    int id;
    int dni;
    int nroCuenta;
    char nombre[30];
    char apellido[30];
    float fondos
} t_persona;


int main(){

    int procesos, registros, listos;
    int  i = 0;

    // Tomamos la cantidad de procesos por parametro o los tomamos con un scanf?

    srand(time(NULL));

    // Crear memoria compartida, solo un t_persona y no un array
    /*
    idMemoria = shm_open...

    ftruncate...

    t_persona *persona = ...

    close(idMemoria)
    */

    // Crear semaforo
    /*
    semaforos = controlTotal, registro 
    sem_t *semaforo = ...
    */

    // un pid para cada proceso
    pid_t pids[procesos];


    // Tomo como proceso coordinador al proceso padre (Revisar esto)
    // Creo los procesos generadores y guardo si pid en en el array pids[]
    for(i ; i < procesos; i++)
    {
        pid_t pid = fork();

        if(pid == -1){
            printf("Error en el fork");
            exit(0);
        }
        else
            if (pid == 0){
                // Es el hijo
            }
            else // es el padre
                pids[i] = pid;
    }

    listos = 0;

    // Abro / Creo el archivo CSV

    if(pid != 0){

        // P(controlTotal) Para que no entre si ya llegamos al limite
        while (listos < registros)
        {
            // NOTA: deberia enviar un puntero a la variable t_persona como parametreo a la funcion generadora
            // De momento deberia recibir 2 parametros, el puntero a la variable y la cantidad (10 o menos) REVISAR

            if((listos - registros) >= 10){
            //funcion generar registro(10)
            //V(controlTotal)
            }
            else{
            //funcion generar registro(listos - registros)
            //V(controlTotal)
            }

            // Escribo en el archivo CSV

            //P(registro) Deberia hacer V() en la funcion que genera
            //REVISAR si es bien la logica del semaforo registro, que actuaria como el del buffer
        }
        
    }

    // Cerrar el archivo CSV

    // Liberar recursos
    /*
    munmap....

    sem_close...

    sem_unlink...

    munmap...
    
    shm_unlink...

    */

    return(0);

    // DEFINIR variables globales para los errores, constantes, etc...

}
